/*
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// This file is automatically generated. Do not modify it.

/**
 * Color science utilities.
 *
 * <p>Utility methods for color science constants and color space conversions that aren't HCT or
 * CAM16.
 */

import UIKit

class ColorUtils {
    private init() {}

    static let SRGB_TO_XYZ = [
        [0.41233895, 0.35762064, 0.18051042],
        [0.2126, 0.7152, 0.0722],
        [
            0.01932141, 0.11916382, 0.95034478,
        ],
    ]

    static let XYZ_TO_SRGB =
        [
            [3.2413774792388685, -1.5376652402851851, -0.49885366846268053],
            [-0.9691452513005321, 1.8758853451067872, 0.04156585616912061],
            [0.05562093689691305, -0.20395524564742123, 1.0571799111220335],
        ]

    static let WHITE_POINT_D65 = [95.047, 100.0, 108.883]

    /** Converts a color from RGB components to ARGB format. */
    static func argbFromRgb(_ red: Int, _ green: Int, _ blue: Int) -> Int {
        return (255 << 24) | ((red & 255) << 16) | ((green & 255) << 8) | (blue & 255)
    }

    /** Converts a color from linear RGB components to ARGB format. */
    static func argbFromLinrgb(_ linrgb: [Double]) -> Int {
        let r = delinearized(linrgb[0])
        let g = delinearized(linrgb[1])
        let b = delinearized(linrgb[2])
        return argbFromRgb(r, g, b)
    }

    /** Returns the alpha component of a color in ARGB format. */
    static func alphaFromArgb(_ argb: Int) -> Int {
        return (argb >> 24) & 255
    }

    /** Returns the red component of a color in ARGB format. */
    static func redFromArgb(_ argb: Int) -> Int {
        return (argb >> 16) & 255
    }

    /** Returns the green component of a color in ARGB format. */
    static func greenFromArgb(_ argb: Int) -> Int {
        return (argb >> 8) & 255
    }

    /** Returns the blue component of a color in ARGB format. */
    static func blueFromArgb(_ argb: Int) -> Int {
        return argb & 255
    }

    /** Returns whether a color in ARGB format is opaque. */
    static func isOpaque(_ argb: Int) -> Bool {
        return alphaFromArgb(argb) >= 255
    }

    /** Converts a color from ARGB to XYZ. */
    static func argbFromXyz(_ x: Double, _ y: Double, _ z: Double) -> Int {
        let matrix = XYZ_TO_SRGB
        let linearR = matrix[0][0] * x + matrix[0][1] * y + matrix[0][2] * z
        let linearG = matrix[1][0] * x + matrix[1][1] * y + matrix[1][2] * z
        let linearB = matrix[2][0] * x + matrix[2][1] * y + matrix[2][2] * z
        let r = delinearized(linearR)
        let g = delinearized(linearG)
        let b = delinearized(linearB)
        return argbFromRgb(r, g, b)
    }

    /** Converts a color from XYZ to ARGB. */
    static func xyzFromArgb(_ argb: Int) -> [Double] {
        let r = linearized(redFromArgb(argb))
        let g = linearized(greenFromArgb(argb))
        let b = linearized(blueFromArgb(argb))
        return MathUtils.matrixMultiply([r, g, b], SRGB_TO_XYZ)
    }

    /** Converts a color represented in Lab color space into an ARGB integer. */
    static func argbFromLab(_ l: Double, _ a: Double, _ b: Double) -> Int {
        let whitePoint = WHITE_POINT_D65
        let fy = (l + 16.0) / 116.0
        let fx = a / 500.0 + fy
        let fz = fy - b / 200.0
        let xNormalized = labInvf(fx)
        let yNormalized = labInvf(fy)
        let zNormalized = labInvf(fz)
        let x = xNormalized * whitePoint[0]
        let y = yNormalized * whitePoint[1]
        let z = zNormalized * whitePoint[2]
        return argbFromXyz(x, y, z)
    }

    /**
     * Converts a color from ARGB representation to L*a*b* representation.
     *
     * @param argb the ARGB representation of a color
     * @return a Lab object representing the color
     */
    static func labFromArgb(_ argb: Int) -> [Double] {
        let linearR = linearized(redFromArgb(argb))
        let linearG = linearized(greenFromArgb(argb))
        let linearB = linearized(blueFromArgb(argb))
        let matrix = SRGB_TO_XYZ
        let x = matrix[0][0] * linearR + matrix[0][1] * linearG + matrix[0][2] * linearB
        let y = matrix[1][0] * linearR + matrix[1][1] * linearG + matrix[1][2] * linearB
        let z = matrix[2][0] * linearR + matrix[2][1] * linearG + matrix[2][2] * linearB
        let whitePoint = WHITE_POINT_D65
        let xNormalized = x / whitePoint[0]
        let yNormalized = y / whitePoint[1]
        let zNormalized = z / whitePoint[2]
        let fx = labF(xNormalized)
        let fy = labF(yNormalized)
        let fz = labF(zNormalized)
        let l = 116.0 * fy - 16
        let a = 500.0 * (fx - fy)
        let b = 200.0 * (fy - fz)
        return [ l, a, b ]
    }

    /**
     * Converts an L* value to an ARGB representation.
     *
     * @param lstar L* in L*a*b*
     * @return ARGB representation of grayscale color with lightness matching L*
     */
    static func argbFromLstar(_ lstar: Double) -> Int {
        let y = yFromLstar(lstar)
        let component = delinearized(y)
        return argbFromRgb(component, component, component)
    }

    /**
     * Computes the L* value of a color in ARGB representation.
     *
     * @param argb ARGB representation of a color
     * @return L*, from L*a*b*, coordinate of the color
     */
    static func lstarFromArgb(_ argb: Int) -> Double {
        let y = xyzFromArgb(argb)[1]
        return 116.0 * labF(y / 100.0) - 16.0
    }

    /**
     * Converts an L* value to a Y value.
     *
     * <p>L* in L*a*b* and Y in XYZ measure the same quantity, luminance.
     *
     * <p>L* measures perceptual luminance, a linear scale. Y in XYZ measures relative luminance, a
     * logarithmic scale.
     *
     * @param lstar L* in L*a*b*
     * @return Y in XYZ
     */
    static func yFromLstar(_ lstar: Double) -> Double {
        return 100.0 * labInvf((lstar + 16.0) / 116.0)
    }

    /**
     * Converts a Y value to an L* value.
     *
     * <p>L* in L*a*b* and Y in XYZ measure the same quantity, luminance.
     *
     * <p>L* measures perceptual luminance, a linear scale. Y in XYZ measures relative luminance, a
     * logarithmic scale.
     *
     * @param y Y in XYZ
     * @return L* in L*a*b*
     */
    static func lstarFromY(_ y: Double) -> Double {
        return labF(y / 100.0) * 116.0 - 16.0
    }

    /**
     * Linearizes an RGB component.
     *
     * @param rgbComponent 0 <= rgb_component <= 255, represents R/G/B channel
     * @return 0.0 <= output <= 100.0, color channel converted to linear RGB space
     */
    static func linearized(_ rgbComponent: Int) -> Double {
        let normalized = Double(rgbComponent) / 255.0
        if normalized <= 0.040449936 {
            return normalized / 12.92 * 100.0
        } else {
            return pow((normalized + 0.055) / 1.055, 2.4) * 100.0
        }
    }

    /**
     * Delinearizes an RGB component.
     *
     * @param rgbComponent 0.0 <= rgb_component <= 100.0, represents linear R/G/B channel
     * @return 0 <= output <= 255, color channel converted to regular RGB space
     */
    static func delinearized(_ rgbComponent: Double) -> Int {
        let normalized = rgbComponent / 100.0
        var delinearized = 0.0
        if normalized <= 0.0031308 {
            delinearized = normalized * 12.92
        } else {
            delinearized = 1.055 * pow(normalized, 1.0 / 2.4) - 0.055
        }
        return MathUtils.clampInt(0, 255, Int(round(delinearized * 255.0)))
    }

    /**
     * Returns the standard white point; white on a sunny day.
     *
     * @return The white point
     */
    static func whitePointD65() -> [Double] {
        return WHITE_POINT_D65
    }

    static func labF(_ t: Double) -> Double {
        let e = 216.0 / 24389.0
        let kappa = 24389.0 / 27.0
        if t > e {
            return pow(t, 1.0 / 3.0)
        } else {
            return (kappa * t + 16) / 116
        }
    }

    static func labInvf(_ ft: Double) -> Double {
        let e = 216.0 / 24389.0
        let kappa = 24389.0 / 27.0
        let ft3 = ft * ft * ft
        if ft3 > e {
            return ft3
        } else {
            return (116 * ft - 16) / kappa
        }
    }
}


public extension UIColor {
    func toInt()->Int? {
        var red: CGFloat = 0
        var blue: CGFloat = 0
        var green: CGFloat = 0
        var alpha: CGFloat = 0
        if getRed(&red, green: &green, blue: &blue, alpha: &alpha) {
            return (Int(alpha * 255.0) << 24) + (Int(red * 255.0) << 16) + (Int(green * 255.0) << 8) + Int(blue * 255.0)
        } else {
            return nil
        }
    }
    
    static func fromInt(_ int: Int)->UIColor? {
        let a = CGFloat((int & 0xFF000000) >> 24) / 255
        let r = CGFloat((int & 0x00FF0000) >> 16) / 255
        let g = CGFloat((int & 0x0000FF00) >> 8) / 255
        let b = CGFloat(int & 0x000000FF) / 255
        return .init(red: r, green: g, blue: b, alpha: a)
    }
}
